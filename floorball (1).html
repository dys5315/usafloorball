<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>FLOORBALL</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Mono:wght@300;400;500&display=swap');

  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --border: #2a2a3a;
    --accent-r: #ff3b3b;
    --accent-g: #00e5a0;
    --accent-y: #ffd23f;
    --text: #f0f0f5;
    --muted: #6b6b80;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    user-select: none;
  }

  .screen {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
  }
  .screen.active {
    opacity: 1;
    pointer-events: all;
  }

  /* ‚îÄ‚îÄ INTRO ‚îÄ‚îÄ */
  #screen-intro {
    background: var(--bg);
    text-align: center;
    gap: 0;
  }
  .brand {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(72px, 20vw, 140px);
    letter-spacing: 0.05em;
    line-height: 0.9;
    color: var(--text);
    position: relative;
  }
  .brand span {
    color: var(--accent-g);
  }
  .subtitle {
    font-size: 11px;
    letter-spacing: 0.3em;
    color: var(--muted);
    text-transform: uppercase;
    margin-top: 16px;
    margin-bottom: 48px;
  }
  .role-row {
    display: flex;
    gap: 12px;
    width: 100%;
    max-width: 380px;
  }
  .role-btn {
    flex: 1;
    padding: 20px 12px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }
  .role-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .role-btn.shooter::before { background: linear-gradient(135deg, rgba(255,59,59,0.15), transparent); }
  .role-btn.goalie::before  { background: linear-gradient(135deg, rgba(0,229,160,0.15), transparent); }
  .role-btn:active::before, .role-btn:hover::before { opacity: 1; }
  .role-btn:active { transform: scale(0.97); }
  .role-icon {
    font-size: 28px;
    display: block;
    margin-bottom: 10px;
  }
  .role-btn.shooter { border-color: rgba(255,59,59,0.4); }
  .role-btn.goalie  { border-color: rgba(0,229,160,0.4); }

  /* ‚îÄ‚îÄ GAME ‚îÄ‚îÄ */
  #screen-game {
    background: var(--bg);
    gap: 0;
    justify-content: space-between;
    padding: 40px 24px 48px;
  }
  .game-header {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    letter-spacing: 0.2em;
    color: var(--muted);
    text-transform: uppercase;
  }
  .score-display {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    color: var(--text);
  }
  .game-arena {
    flex: 1;
    width: 100%;
    max-width: 380px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    margin: 20px 0;
  }
  .pitch {
    width: 100%;
    aspect-ratio: 3/4;
    max-height: 52vh;
    background: #0f1a14;
    border: 1px solid #1a3025;
    border-radius: 4px;
    position: relative;
    overflow: hidden;
  }
  .pitch-lines {
    position: absolute;
    inset: 0;
  }
  /* center line */
  .pitch::before {
    content: '';
    position: absolute;
    left: 0; right: 0;
    top: 50%;
    height: 1px;
    background: #1a3025;
  }
  /* goal top */
  .goal-top {
    position: absolute;
    top: 8%;
    left: 30%;
    width: 40%;
    height: 10%;
    border: 1px solid #2a5040;
    border-top: none;
    background: rgba(0,229,160,0.05);
  }
  /* goal bottom */
  .goal-bottom {
    position: absolute;
    bottom: 8%;
    left: 30%;
    width: 40%;
    height: 10%;
    border: 1px solid #2a5040;
    border-bottom: none;
    background: rgba(255,59,59,0.05);
  }
  .player {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    touch-action: none;
    transition: box-shadow 0.15s;
    /* size set via JS */
  }
  .player:active { cursor: grabbing; }
  .player-user {
    background: rgba(255,59,59,0.2);
    border: 2px solid var(--accent-r);
    box-shadow: 0 0 0 0 rgba(255,59,59,0);
  }
  .player-user.dragging {
    box-shadow: 0 0 0 8px rgba(255,59,59,0.2);
  }
  .player-goalie {
    background: rgba(0,229,160,0.2);
    border: 2px solid var(--accent-g);
    box-shadow: 0 0 0 0 rgba(0,229,160,0);
  }
  .player-goalie.dragging {
    box-shadow: 0 0 0 8px rgba(0,229,160,0.2);
  }
  .ball {
    position: absolute;
    width: 12px;
    height: 12px;
    background: white;
    border-radius: 50%;
    pointer-events: none;
    box-shadow: 0 0 8px rgba(255,255,255,0.6);
  }

  /* shoot button ‚Äî full width below pitch for shooter */
  .shoot-bar {
    width: 100%;
    max-width: 380px;
    margin-top: 10px;
  }
  .shoot-bar-btn {
    width: 100%;
    padding: 16px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.1s;
  }
  .shoot-bar-btn.primed {
    border-color: var(--accent-y);
    background: rgba(255,210,63,0.08);
    color: var(--accent-y);
    animation: pulse-border 0.6s ease infinite alternate;
  }
  .shoot-bar-btn:active { transform: scale(0.98); }

  /* depth indicator for goalie */
  .depth-bar-wrap {
    width: 100%;
    max-width: 380px;
    margin-top: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 10px;
    letter-spacing: 0.2em;
    color: var(--muted);
    text-transform: uppercase;
  }
  .depth-bar-track {
    flex: 1;
    height: 3px;
    background: var(--border);
    position: relative;
  }
  .depth-bar-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    background: var(--accent-g);
    transition: width 0.1s;
  }

  .prompt-zone {
    width: 100%;
    max-width: 380px;
  }
  .game-prompt {
    font-size: 11px;
    letter-spacing: 0.15em;
    color: var(--muted);
    text-transform: uppercase;
    text-align: center;
    margin-bottom: 12px;
    min-height: 18px;
  }
  @keyframes pulse-border {
    from { box-shadow: 0 0 0 0 rgba(255,210,63,0.3); }
    to   { box-shadow: 0 0 0 8px rgba(255,210,63,0); }
  }

  /* ‚îÄ‚îÄ RESULT ‚îÄ‚îÄ */
  #screen-result {
    background: var(--bg);
    text-align: center;
    gap: 24px;
    padding: 48px 28px;
  }
  .result-verdict {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(56px, 16vw, 100px);
    line-height: 0.9;
    letter-spacing: 0.05em;
  }
  .result-verdict.win  { color: var(--accent-g); }
  .result-verdict.lose { color: var(--accent-r); }

  .result-stats {
    display: flex;
    gap: 16px;
    justify-content: center;
  }
  .stat-chip {
    padding: 8px 14px;
    border: 1px solid var(--border);
    font-size: 10px;
    letter-spacing: 0.2em;
    color: var(--muted);
    text-transform: uppercase;
  }
  .stat-chip strong {
    display: block;
    font-size: 16px;
    font-family: 'Bebas Neue', sans-serif;
    color: var(--text);
    letter-spacing: 0.1em;
    margin-bottom: 2px;
  }

  .insight-box {
    width: 100%;
    max-width: 360px;
    border: 1px solid var(--border);
    background: var(--surface);
    padding: 20px;
    text-align: left;
    position: relative;
  }
  .insight-label {
    font-size: 9px;
    letter-spacing: 0.3em;
    color: var(--accent-g);
    text-transform: uppercase;
    margin-bottom: 10px;
  }
  .insight-text {
    font-size: 13px;
    line-height: 1.65;
    color: var(--text);
    min-height: 60px;
  }
  .insight-text.loading {
    color: var(--muted);
    animation: blink 1s ease infinite;
  }
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  .profile-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
  }
  .tag {
    padding: 5px 12px;
    font-size: 10px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    border: 1px solid var(--border);
    color: var(--muted);
  }

  .share-btn {
    width: 100%;
    max-width: 360px;
    padding: 16px;
    background: var(--accent-g);
    border: none;
    color: #0a0a0f;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 20px;
    letter-spacing: 0.15em;
    cursor: pointer;
    transition: all 0.15s;
  }
  .share-btn:active { transform: scale(0.98); opacity: 0.9; }

  .play-again {
    font-size: 11px;
    letter-spacing: 0.2em;
    color: var(--muted);
    text-transform: uppercase;
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    font-family: 'DM Mono', monospace;
    text-decoration: underline;
    text-underline-offset: 3px;
  }

  /* ‚îÄ‚îÄ GOALIE VARIANT ‚îÄ‚îÄ */
  .direction-row {
    display: flex;
    gap: 10px;
    width: 100%;
    max-width: 380px;
  }
  .dir-btn {
    flex: 1;
    padding: 16px 8px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 18px;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.1s;
  }
  .dir-btn:active { background: rgba(0,229,160,0.15); border-color: var(--accent-g); transform: scale(0.96); }

  .countdown-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60px;
    height: 60px;
    pointer-events: none;
  }
  .countdown-ring circle {
    fill: none;
    stroke: var(--accent-y);
    stroke-width: 3;
    stroke-linecap: round;
    stroke-dasharray: 163;
    stroke-dashoffset: 163;
    transition: stroke-dashoffset 0.05s linear;
    transform-origin: center;
    transform: rotate(-90deg);
  }

  .ripple {
    position: absolute;
    border-radius: 50%;
    background: rgba(255,210,63,0.3);
    transform: scale(0);
    animation: ripple-out 0.4s ease-out forwards;
    pointer-events: none;
  }
  @keyframes ripple-out {
    to { transform: scale(4); opacity: 0; }
  }

  /* noise overlay */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.03'/%3E%3C/svg%3E");
    pointer-events: none;
    opacity: 0.4;
    z-index: 999;
  }
</style>
</head>
<body>

<!-- ‚îÄ‚îÄ INTRO SCREEN ‚îÄ‚îÄ -->
<div class="screen active" id="screen-intro">
  <div class="brand">FLOOR<span>BALL</span></div>
  <div class="subtitle">1v1 ¬∑ Prove yourself</div>
  <div class="role-row">
    <button class="role-btn shooter" onclick="chooseRole('shooter')">
      <span class="role-icon">üèí</span>
      SHOOTER
    </button>
    <button class="role-btn goalie" onclick="chooseRole('goalie')">
      <span class="role-icon">üß§</span>
      GOALIE
    </button>
  </div>
</div>

<!-- ‚îÄ‚îÄ GAME SCREEN ‚îÄ‚îÄ -->
<div class="screen" id="screen-game">
  <div class="game-header">
    <span id="role-label">SHOOTER</span>
    <span class="score-display" id="score-display">0 ‚Äì 0</span>
    <span id="round-label">RND 1/5</span>
  </div>

  <div class="game-arena">
    <div class="pitch" id="pitch">
      <div class="goal-top"></div>
      <div class="goal-bottom"></div>
      <div class="player player-goalie" id="goalie-player">üß§</div>
      <div class="ball" id="ball"></div>
      <div class="player player-user" id="user-player">üèí</div>
    </div>
  </div>

  <div class="prompt-zone">
    <div class="game-prompt" id="game-prompt">DRAG TO POSITION</div>
    <!-- Shooter: shoot button -->
    <div class="shoot-bar" id="shooter-controls">
      <button class="shoot-bar-btn" id="shoot-btn" onclick="handleShoot()">SHOOT</button>
    </div>
    <!-- Goalie: depth indicator -->
    <div class="depth-bar-wrap" id="goalie-controls" style="display:none">
      <span>DEEP</span>
      <div class="depth-bar-track"><div class="depth-bar-fill" id="depth-bar"></div></div>
      <span>OUT</span>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ RESULT SCREEN ‚îÄ‚îÄ -->
<div class="screen" id="screen-result">
  <div class="result-verdict" id="result-verdict">GOAL!</div>
  <div class="result-stats">
    <div class="stat-chip"><strong id="stat-react">‚Äî</strong>Reaction</div>
    <div class="stat-chip"><strong id="stat-attempts">‚Äî</strong>Attempts</div>
    <div class="stat-chip"><strong id="stat-score">‚Äî</strong>Final Score</div>
  </div>
  <div class="insight-box">
    <div class="insight-label">Your Player Profile</div>
    <div class="insight-text loading" id="insight-text">Analyzing your play style...</div>
  </div>
  <div class="profile-tags" id="profile-tags"></div>
  <button class="share-btn" onclick="shareResult()">SHARE YOUR RESULT</button>
  <button class="play-again" onclick="resetGame()">play again</button>
</div>

<script>
// ‚îÄ‚îÄ CONFIG ‚îÄ‚îÄ
const ANTHROPIC_API_KEY = 'YOUR_API_KEY_HERE';
const SUPABASE_URL      = 'YOUR_SUPABASE_URL';
const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY';

// ‚îÄ‚îÄ PITCH BOUNDS (% of pitch dimensions) ‚îÄ‚îÄ
const ZONES = {
  shooter: { xMin: 8,  xMax: 92, yMin: 48, yMax: 90 },
  goalie:  { xMin: 15, xMax: 85, yMin: 8,  yMax: 40 }
};
const GOALIE_SIZE = { min: 32, max: 72 }; // px diameter ‚Äî grows as goalie comes out
const SHOOTER_SIZE = 36; // px, fixed
const GOAL_ZONE = { xMin: 30, xMax: 70, yTop: 8, yBottom: 22 };

// ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
let state = {
  role: null, round: 0, totalRounds: 5,
  userScore: 0, oppScore: 0,
  reactionTimes: [], earlyTaps: 0, tapCount: 0,
  primeTime: null, primed: false, roundActive: false,
  outcome: null, sessionStart: Date.now(),
  decisionStyle: null,
  // movement signals
  shooterPositionHistory: [],
  goalieDepthHistory: [],      // 0=deep 1=out (normalized)
  directionChanges: 0,
  shootPositions: [],
  goalieAvgDepth: 0,           // behavioral: how aggressive was goalie
  _events: []
};

// Live positions (% of pitch)
let playerPos = { x: 50, y: 78 };
let goaliePos = { x: 50, y: 15 };
let ballPos   = { x: 50, y: 73 };

// Goalie depth: 0 = hugging goal line, 1 = fully out
let goalieDepth = 0;

let goalieAITimer = null;
let renderLoop = null;

// ‚îÄ‚îÄ ROLE CHOICE ‚îÄ‚îÄ
function chooseRole(role) {
  state.role = role;
  logEvent('role_chosen', { role });
  document.getElementById('role-label').textContent = role.toUpperCase();

  if (role === 'goalie') {
    playerPos = { x: 50, y: 15 };
    goaliePos = { x: 50, y: 78 }; // "goalie" is now the AI shooter
    document.getElementById('user-player').textContent  = 'üß§';
    document.getElementById('goalie-player').textContent = 'üèí';
    document.getElementById('shooter-controls').style.display = 'none';
    document.getElementById('goalie-controls').style.display  = 'flex';
  } else {
    playerPos = { x: 50, y: 78 };
    goaliePos = { x: 50, y: 15 };
  }

  showScreen('screen-game');
  initDragControls();
  setTimeout(startRound, 500);
}

// ‚îÄ‚îÄ DIRECT DRAG CONTROLS ‚îÄ‚îÄ
function initDragControls() {
  const pitch    = document.getElementById('pitch');
  const userEl   = document.getElementById('user-player');
  const goalieEl = document.getElementById('goalie-player');

  // Size up both players initially
  applyPlayerSize(userEl,   state.role === 'goalie' ? getGoalieSize() : SHOOTER_SIZE);
  applyPlayerSize(goalieEl, state.role === 'goalie' ? SHOOTER_SIZE : getGoalieSize());

  // The draggable element depends on role
  const dragEl = userEl;
  let dragging = false;
  let activeTouchId = null;

  function getRelativePos(clientX, clientY) {
    const r = pitch.getBoundingClientRect();
    return {
      x: Math.max(0, Math.min(100, (clientX - r.left)  / r.width  * 100)),
      y: Math.max(0, Math.min(100, (clientY - r.top)   / r.height * 100))
    };
  }

  function onDragStart(clientX, clientY) {
    // Only start drag if touch is near the player
    const r = pitch.getBoundingClientRect();
    const px = playerPos.x / 100 * r.width  + r.left;
    const py = playerPos.y / 100 * r.height + r.top;
    const dist = Math.hypot(clientX - px, clientY - py);
    const threshold = (state.role === 'goalie' ? getGoalieSize() : SHOOTER_SIZE) * 1.8;
    if (dist > threshold) return;

    dragging = true;
    dragEl.classList.add('dragging');
    logEvent('drag_start', { round: state.round, pos: {...playerPos} });
  }

  function onDragMove(clientX, clientY) {
    if (!dragging) return;
    const pos = getRelativePos(clientX, clientY);
    const zone = state.role === 'shooter' ? ZONES.shooter : ZONES.goalie;

    const prevX = playerPos.x;
    playerPos.x = Math.max(zone.xMin, Math.min(zone.xMax, pos.x));
    playerPos.y = Math.max(zone.yMin, Math.min(zone.yMax, pos.y));

    if (state.role === 'goalie') {
      // Depth: yMin=deepest (0), yMax=most out (1)
      goalieDepth = (playerPos.y - zone.yMin) / (zone.yMax - zone.yMin);
      state.goalieDepthHistory.push(goalieDepth);
      // Update goalie size and depth bar
      const size = getGoalieSize();
      applyPlayerSize(dragEl, size);
      document.getElementById('depth-bar').style.width = (goalieDepth * 100) + '%';
    }

    // Track direction changes for shooter
    if (state.role === 'shooter') {
      state.shooterPositionHistory.push({ x: playerPos.x, y: playerPos.y, t: Date.now() - state.sessionStart });
    }

    // Ball sticks to shooter
    if (state.role === 'shooter' && !state.primed) {
      ballPos.x = playerPos.x;
      ballPos.y = playerPos.y - 5;
    }

    renderPositions();
  }

  function onDragEnd() {
    if (!dragging) return;
    dragging = false;
    dragEl.classList.remove('dragging');
    logEvent('drag_end', { round: state.round, pos: {...playerPos}, depth: goalieDepth });
  }

  // Touch events
  dragEl.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    activeTouchId = t.identifier;
    onDragStart(t.clientX, t.clientY);
  }, { passive: false });

  // Use pitch as the move/end target so drag doesn't break when finger moves fast
  pitch.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === activeTouchId) {
        onDragMove(t.clientX, t.clientY);
        break;
      }
    }
  }, { passive: false });

  pitch.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
      if (t.identifier === activeTouchId) { onDragEnd(); break; }
    }
  }, { passive: false });

  // Mouse fallback for desktop testing
  dragEl.addEventListener('mousedown', e => onDragStart(e.clientX, e.clientY));
  window.addEventListener('mousemove', e => onDragMove(e.clientX, e.clientY));
  window.addEventListener('mouseup',   onDragEnd);
}

function getGoalieSize() {
  // Deeper (0) = smaller, further out (1) = bigger
  return GOALIE_SIZE.min + goalieDepth * (GOALIE_SIZE.max - GOALIE_SIZE.min);
}

function applyPlayerSize(el, sizePx) {
  el.style.width  = sizePx + 'px';
  el.style.height = sizePx + 'px';
  el.style.fontSize = (sizePx * 0.5) + 'px';
}

// ‚îÄ‚îÄ GOALIE AI (for shooter mode) ‚îÄ‚îÄ
function startGoalieAI() {
  if (goalieAITimer) clearInterval(goalieAITimer);
  goalieAITimer = setInterval(() => {
    if (!state.roundActive) return;
    // Tracks shooter x with lag + noise
    const lag   = 0.07 + Math.random() * 0.05;
    const noise = (Math.random() - 0.5) * 10;
    goaliePos.x += (playerPos.x + noise - goaliePos.x) * lag;
    goaliePos.x  = Math.max(ZONES.goalie.xMin, Math.min(ZONES.goalie.xMax, goaliePos.x));
    renderPositions();
  }, 50);
}

function stopGoalieAI() {
  if (goalieAITimer) clearInterval(goalieAITimer);
  goalieAITimer = null;
}

// ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ
function renderPositions() {
  const pitch = document.getElementById('pitch');
  const pw = pitch.offsetWidth, ph = pitch.offsetHeight;
  const userEl   = document.getElementById('user-player');
  const goalieEl = document.getElementById('goalie-player');
  const ballEl   = document.getElementById('ball');

  positionEl(userEl,   playerPos.x, playerPos.y, pw, ph);
  positionEl(goalieEl, goaliePos.x, goaliePos.y, pw, ph);
  positionEl(ballEl,   ballPos.x,   ballPos.y,   pw, ph);

  // Goalie size update (shooter mode: AI goalie size reflects depth from center)
  if (state.role === 'shooter') {
    const distFromCenter = Math.abs(goaliePos.y - ZONES.goalie.yMin) / (ZONES.goalie.yMax - ZONES.goalie.yMin);
    const aiSize = GOALIE_SIZE.min + distFromCenter * (GOALIE_SIZE.max - GOALIE_SIZE.min) * 0.4;
    applyPlayerSize(goalieEl, GOALIE_SIZE.min + 8); // AI goalie stays consistent size
  }
}

function positionEl(el, xPct, yPct, pw, ph) {
  el.style.left = (xPct / 100 * pw) + 'px';
  el.style.top  = (yPct / 100 * ph) + 'px';
  el.style.transform = 'translate(-50%, -50%)';
}

// ‚îÄ‚îÄ ROUNDS ‚îÄ‚îÄ
function startRound() {
  state.round++;
  state.roundActive = false;
  state.primed = false;
  state.primeTime = null;
  updateHUD();

  if (state.role === 'shooter') {
    playerPos = { x: 50, y: 78 };
    ballPos   = { x: 50, y: 73 };
    goaliePos = { x: 50, y: 15 };
    applyPlayerSize(document.getElementById('user-player'), SHOOTER_SIZE);
    applyPlayerSize(document.getElementById('goalie-player'), GOALIE_SIZE.min + 8);
    renderPositions();
    setPrompt('DRAG INTO POSITION');
    startGoalieAI();
    setTimeout(primeShot, 1800 + Math.random() * 2000);
  } else {
    goaliePos = { x: 50, y: 78 }; // AI shooter
    playerPos = { x: 50, y: 15 }; // user goalie
    goalieDepth = 0;
    applyPlayerSize(document.getElementById('user-player'), getGoalieSize());
    renderPositions();
    setPrompt('GET IN POSITION');
    document.getElementById('depth-bar').style.width = '0%';
    setTimeout(primeGoalie, 1500 + Math.random() * 1500);
  }
}

function primeShot() {
  if (state.round > state.totalRounds) return;
  state.primed = true;
  state.primeTime = Date.now();
  state.roundActive = true;
  setPrompt('SHOOT NOW!');
  document.getElementById('shoot-btn').classList.add('primed');
  setTimeout(() => { if (state.roundActive) resolveRound(false, 'timeout'); }, 1800);
}

function primeGoalie() {
  state.primed = true;
  state.primeTime = Date.now();
  state.roundActive = true;
  setPrompt('BLOCK IT!');
  animateAIShot();
  setTimeout(() => { if (state.roundActive) resolveRound(false, 'timeout'); }, 2000);
}

// ‚îÄ‚îÄ ACTIONS ‚îÄ‚îÄ
function handleShoot() {
  state.tapCount++;
  if (!state.primed) {
    state.earlyTaps++;
    document.getElementById('shoot-btn').style.borderColor = 'var(--accent-r)';
    setTimeout(() => document.getElementById('shoot-btn').style.borderColor = '', 250);
    logEvent('early_tap', { round: state.round });
    return;
  }
  if (!state.roundActive) return;

  const rt = Date.now() - state.primeTime;
  state.reactionTimes.push(rt);
  state.shootPositions.push({ ...playerPos, goalieX: goaliePos.x });

  // Gap between shooter and goalie x = scoring chance
  const gap = Math.abs(playerPos.x - goaliePos.x);
  const scored = determineGoal(gap, rt);
  logEvent('shoot', { round: state.round, rt, pos: {...playerPos}, goaliePos: {...goaliePos}, scored });
  resolveRound(scored, 'shot', rt);
}

function determineGoal(gap, rt) {
  // Wider gap = better. Also factor: if shot is fast after prime, goalie hasn't fully adjusted
  const gapScore = Math.min(1, gap / 35);
  const speedBonus = rt < 400 ? 0.15 : 0;
  return Math.random() < (gapScore * 0.8 + speedBonus);
}

// Goalie: the save happens based on whether user's goalie position covers the shot
function animateAIShot() {
  const pitch = document.getElementById('pitch');
  const pw = pitch.offsetWidth, ph = pitch.offsetHeight;
  const ballEl = document.getElementById('ball');

  // AI shoots to a random spot near user's goal (bottom)
  const shotX = 25 + Math.random() * 50;
  const shotY = 82;
  // Store where AI is shooting so we can check on block attempt
  state._aiShotTarget = { x: shotX, y: shotY };

  // Animate AI shooter moving slightly
  goaliePos.x = 40 + Math.random() * 20;
  renderPositions();

  setTimeout(() => {
    ballPos = { x: shotX, y: shotY };
    ballEl.style.transition = 'left 0.35s ease-in, top 0.35s ease-in';
    positionEl(ballEl, shotX, shotY, pw, ph);
    setTimeout(() => ballEl.style.transition = '', 400);
  }, 400);
}

// For goalie: block on tap anywhere, evaluated on proximity
document.addEventListener('touchstart', handleGoalieBlock, { passive: true });
document.addEventListener('mousedown',  handleGoalieBlock);

function handleGoalieBlock(e) {
  if (state.role !== 'goalie' || !state.roundActive || !state.primed) return;
  // Ignore taps on buttons
  if (e.target.closest('button')) return;

  const rt = Date.now() - state.primeTime;
  state.reactionTimes.push(rt);
  state.tapCount++;

  const shotTarget = state._aiShotTarget || { x: 50, y: 82 };
  // Check proximity of goalie to shot target
  const dx = playerPos.x - shotTarget.x;
  const dy = playerPos.y - 90; // goal mouth is near bottom
  const dist = Math.hypot(dx, dy);
  // Bigger goalie (more out) = larger effective radius
  const radius = 12 + goalieDepth * 18;
  const saved = dist < radius;

  state.goalieAvgDepth = state.goalieDepthHistory.length
    ? state.goalieDepthHistory.reduce((a,b) => a+b,0) / state.goalieDepthHistory.length
    : 0;

  logEvent('block_attempt', { round: state.round, rt, playerPos: {...playerPos}, goalieDepth, dist, saved });
  resolveRound(saved, 'block', rt);
}

// ‚îÄ‚îÄ RESOLVE ‚îÄ‚îÄ
function resolveRound(success, method, rt) {
  state.roundActive = false;
  stopGoalieAI();
  document.getElementById('shoot-btn').classList.remove('primed');

  if (success) { state.userScore++; animateGoalFx(true); }
  else         { state.oppScore++;  animateGoalFx(false); }

  logEvent('round_end', { round: state.round, success, method });
  if (state.round >= 2) checkBranch();

  setTimeout(() => {
    if (state.round >= state.totalRounds) finalizeOutcome();
    else startRound();
  }, 1000);
}

// ‚îÄ‚îÄ ANIMATIONS ‚îÄ‚îÄ
function animateGoalFx(scored) {
  const pitch  = document.getElementById('pitch');
  const pw = pitch.offsetWidth, ph = pitch.offsetHeight;
  const ballEl = document.getElementById('ball');

  if (scored && state.role === 'shooter') {
    const tx = GOAL_ZONE.xMin + Math.random() * (GOAL_ZONE.xMax - GOAL_ZONE.xMin);
    const ty = 14;
    ballEl.style.transition = 'left 0.3s ease-in, top 0.3s ease-in, box-shadow 0.2s';
    positionEl(ballEl, tx, ty, pw, ph);
    ballEl.style.boxShadow = '0 0 24px rgba(0,229,160,0.9)';
    setPrompt('‚ö° GOAL!');
  } else if (!scored && state.role === 'shooter') {
    ballEl.style.transition = 'left 0.2s, top 0.2s, box-shadow 0.2s';
    positionEl(ballEl, goaliePos.x, goaliePos.y, pw, ph);
    ballEl.style.boxShadow = '0 0 20px rgba(255,59,59,0.8)';
    setPrompt('SAVED!');
    const gEl = document.getElementById('goalie-player');
    gEl.style.transform = 'translate(-50%,-50%) scale(1.3)';
    setTimeout(() => gEl.style.transform = 'translate(-50%,-50%) scale(1)', 350);
  } else if (scored && state.role === 'goalie') {
    setPrompt('BLOCKED!');
    const uEl = document.getElementById('user-player');
    uEl.style.transform = 'translate(-50%,-50%) scale(1.3)';
    setTimeout(() => uEl.style.transform = 'translate(-50%,-50%) scale(1)', 350);
  } else {
    setPrompt('GOAL CONCEDED!');
    ballEl.style.boxShadow = '0 0 20px rgba(255,59,59,0.8)';
  }

  setTimeout(() => {
    ballEl.style.transition = '';
    ballEl.style.boxShadow  = '0 0 8px rgba(255,255,255,0.6)';
    ballPos = { x: playerPos.x, y: playerPos.y - 5 };
    renderPositions();
  }, 750);
}

// ‚îÄ‚îÄ BRANCHING ‚îÄ‚îÄ
function checkBranch() {
  const avgRT = state.reactionTimes.reduce((a,b)=>a+b,0) / (state.reactionTimes.length||1);
  const earlyRatio = state.earlyTaps / Math.max(state.tapCount, 1);

  if (state.role === 'goalie') {
    // Goalie behavioral signals
    const avgDepth = state.goalieDepthHistory.length
      ? state.goalieDepthHistory.reduce((a,b)=>a+b,0) / state.goalieDepthHistory.length : 0;
    state.goalieAvgDepth = avgDepth;
    if (avgDepth > 0.65) state.decisionStyle = 'aggressive';       // comes out big
    else if (avgDepth < 0.25) state.decisionStyle = 'conservative'; // stays deep
    else if (avgRT < 400) state.decisionStyle = 'reactive';
    else state.decisionStyle = 'calculated';
  } else {
    if (earlyRatio > 0.3) state.decisionStyle = 'impulsive';
    else if (avgRT < 380) state.decisionStyle = 'reactive';
    else if (avgRT > 700) state.decisionStyle = 'deliberate';
    else state.decisionStyle = 'calculated';
  }
}

function finalizeOutcome() {
  if (!state.decisionStyle) checkBranch();
  const map = {
    impulsive:    'lose',
    reactive:     'lose',
    deliberate:   'win',
    calculated:   'win',
    aggressive:   'lose', // overextended ‚Äî got beat
    conservative: 'win'   // stayed disciplined
  };
  state.outcome = map[state.decisionStyle] || (Math.random() > 0.5 ? 'win' : 'lose');

  if (state.outcome === 'win') {
    state.userScore = Math.max(state.userScore, 3);
    state.oppScore  = Math.min(state.oppScore, state.userScore - 1);
  } else {
    state.oppScore  = Math.max(state.oppScore, 3);
    state.userScore = Math.min(state.userScore, state.oppScore - 1);
  }
  showResults();
}

// ‚îÄ‚îÄ RESULTS ‚îÄ‚îÄ
function showResults() {
  updateHUD();
  showScreen('screen-result');

  const won = state.outcome === 'win';
  const verdict = document.getElementById('result-verdict');
  if (state.role === 'shooter') verdict.textContent = won ? 'SCORED!' : 'DENIED!';
  else verdict.textContent = won ? 'CLEAN SHEET!' : 'CONCEDED!';
  verdict.className = 'result-verdict ' + (won ? 'win' : 'lose');

  const avgRT = Math.round(state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1));
  document.getElementById('stat-react').textContent    = avgRT + 'ms';
  document.getElementById('stat-attempts').textContent = state.tapCount;
  document.getElementById('stat-score').textContent    = `${state.userScore}‚Äì${state.oppScore}`;

  buildProfileTags();
  generateInsight();
  saveToSupabase();
}

function buildProfileTags() {
  const tags = [];
  const avgRT = state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1);
  tags.push(state.role === 'shooter' ? 'ATTACKER' : 'DEFENDER');
  if (state.earlyTaps > 1) tags.push('TRIGGER HAPPY');
  if (avgRT < 350) tags.push('LIGHTNING REFLEX');
  else if (avgRT > 700) tags.push('PATIENT');
  if (state.role === 'goalie' && state.goalieAvgDepth > 0.6) tags.push('HIGH LINE');
  if (state.role === 'goalie' && state.goalieAvgDepth < 0.25) tags.push('DEEP BLOCKER');
  if (state.decisionStyle) tags.push(state.decisionStyle.toUpperCase());
  document.getElementById('profile-tags').innerHTML = tags.map(t => `<span class="tag">${t}</span>`).join('');
}

async function generateInsight() {
  const avgRT = Math.round(state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1));
  const profile = {
    role: state.role, outcome: state.outcome,
    decisionStyle: state.decisionStyle, avgReactionMs: avgRT,
    earlyTaps: state.earlyTaps, totalTaps: state.tapCount,
    goalieAvgDepth: state.goalieAvgDepth?.toFixed(2),
    score: `${state.userScore}-${state.oppScore}`
  };

  const prompt = `You are a behavioral psychologist. A person just played a floorball mini-game. Write a 2-sentence personality insight based on their data. Be specific, a little provocative ‚Äî make it feel like you truly see them. Close with one sharp observation about how they approach real-life challenges. Only output the insight, no labels or quotes.\n\nData: ${JSON.stringify(profile)}`;

  try {
    const res = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-api-key': ANTHROPIC_API_KEY, 'anthropic-version': '2023-06-01' },
      body: JSON.stringify({ model: 'claude-sonnet-4-20250514', max_tokens: 130, messages: [{ role: 'user', content: prompt }] })
    });
    const data = await res.json();
    const text = data.content?.[0]?.text || fallbackInsight(profile);
    const el = document.getElementById('insight-text');
    el.classList.remove('loading');
    el.textContent = text;
  } catch(e) {
    document.getElementById('insight-text').textContent = fallbackInsight(profile);
    document.getElementById('insight-text').classList.remove('loading');
  }
}

function fallbackInsight(p) {
  const lines = {
    impulsive:    "You fire before the picture is clear ‚Äî sometimes that's right, which makes it worse. In life, you'd rather beg forgiveness than ask permission.",
    reactive:     "You're wired for the moment, not the plan. When pressure arrives you come alive; when it doesn't, you drift.",
    deliberate:   "You took your time even when it cost you. That patience is rare ‚Äî but in a fast game it becomes the liability you can't ignore.",
    calculated:   "Every move felt considered, even under fire. You play the long game ‚Äî the trap is when there's no long game, just now.",
    aggressive:   "You came out swinging ‚Äî high line, big presence, maximum threat. In real life you take up space before you've earned it, and sometimes it works.",
    conservative: "You stayed disciplined and let the game come to you. Most people call that passive. You call it control."
  };
  return lines[p.decisionStyle] || lines.calculated;
}

async function saveToSupabase() {
  if (!SUPABASE_URL || SUPABASE_URL.includes('YOUR_')) return;
  const avgRT = Math.round(state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1));
  try {
    await fetch(`${SUPABASE_URL}/rest/v1/floorball_sessions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` },
      body: JSON.stringify({
        role: state.role, outcome: state.outcome,
        decision_style: state.decisionStyle,
        avg_reaction_ms: avgRT,
        early_taps: state.earlyTaps, total_taps: state.tapCount,
        goalie_avg_depth: state.goalieAvgDepth,
        final_score: `${state.userScore}-${state.oppScore}`,
        reaction_times: state.reactionTimes,
        shoot_positions: state.shootPositions,
        session_duration_ms: Date.now() - state.sessionStart,
        created_at: new Date().toISOString()
      })
    });
  } catch(e) { /* silent */ }
}

// ‚îÄ‚îÄ UI HELPERS ‚îÄ‚îÄ
function setPrompt(t) { document.getElementById('game-prompt').textContent = t; }
function updateHUD() {
  document.getElementById('score-display').textContent = `${state.userScore} ‚Äì ${state.oppScore}`;
  document.getElementById('round-label').textContent = `RND ${Math.min(state.round, state.totalRounds)}/${state.totalRounds}`;
}
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function shareResult() {
  const text = `I went ${state.userScore}-${state.oppScore} as ${state.role} ‚Äî profile: ${state.decisionStyle?.toUpperCase()}. Can you beat it? üèí`;
  if (navigator.share) navigator.share({ title: 'FLOORBALL', text, url: window.location.href });
  else { navigator.clipboard?.writeText(text); alert('Copied!'); }
}
function resetGame() {
  stopGoalieAI();
  state = {
    role: null, round: 0, totalRounds: 5, userScore: 0, oppScore: 0,
    reactionTimes: [], earlyTaps: 0, tapCount: 0,
    primeTime: null, primed: false, roundActive: false,
    outcome: null, sessionStart: Date.now(), decisionStyle: null,
    shooterPositionHistory: [], goalieDepthHistory: [],
    directionChanges: 0, shootPositions: [], goalieAvgDepth: 0, _events: []
  };
  playerPos = { x: 50, y: 78 };
  goaliePos = { x: 50, y: 15 };
  ballPos   = { x: 50, y: 73 };
  goalieDepth = 0;
  document.getElementById('insight-text').textContent = 'Analyzing your play style...';
  document.getElementById('insight-text').classList.add('loading');
  document.getElementById('shooter-controls').style.display = 'block';
  document.getElementById('goalie-controls').style.display  = 'none';
  showScreen('screen-intro');
}
function logEvent(type, data) {
  state._events.push({ type, data, t: Date.now() - state.sessionStart });
}
</script>

<!-- old script removed -->
<!--
let state = {
  role: null, round: 0, totalRounds: 5,
  userScore: 0, oppScore: 0,
  reactionTimes: [], earlyTaps: 0, tapCount: 0,
  primeTime: null, primed: false, roundActive: false,
  outcome: null, sessionStart: Date.now(),
  decisionStyle: null,
  // movement tracking
  positionHistory: [],   // [{x,y,t}] for the round
  directionChanges: 0,
  hesitationMs: 0,       // time spent nearly stationary before shoot
  shootPositions: [],    // where on pitch player shot from
  _events: []
};

// Pitch coordinate system: 0-100 in both axes (% of pitch)
let playerPos  = { x: 50, y: 78 }; // shooter starts bottom center
let goaliePos  = { x: 50, y: 12 };
let ballPos    = { x: 50, y: 75 };
let joystickActive = false;
let joystickOrigin = { x: 0, y: 0 };
let joystickDelta  = { x: 0, y: 0 };
let animFrame = null;

// ‚îÄ‚îÄ PITCH BOUNDS ‚îÄ‚îÄ
const SHOOTER_ZONE = { xMin: 10, xMax: 90, yMin: 45, yMax: 92 };
const GOALIE_PATROL = { xMin: 25, xMax: 75, yMin: 8, yMax: 28 };
const GOAL_X = { min: 30, max: 70 };
const GOAL_Y = 18; // top goal y%

// ‚îÄ‚îÄ ROLE CHOICE ‚îÄ‚îÄ
function chooseRole(role) {
  state.role = role;
  logEvent('role_chosen', { role });

  document.getElementById('role-label').textContent = role.toUpperCase();

  if (role === 'goalie') {
    // swap visuals
    document.getElementById('user-player').textContent  = 'üß§';
    document.getElementById('goalie-player').textContent = 'üèí';
    playerPos  = { x: 50, y: 12 };
    goaliePos  = { x: 50, y: 78 };
    document.getElementById('shooter-controls').style.display = 'none';
    document.getElementById('goalie-controls').style.display  = 'flex';
  }

  renderPositions();
  showScreen('screen-game');
  initJoystick();
  setTimeout(startRound, 600);
}

// ‚îÄ‚îÄ JOYSTICK ‚îÄ‚îÄ
function initJoystick() {
  if (state.role !== 'shooter') return;
  const base  = document.getElementById('joystick-base');
  const thumb = document.getElementById('joystick-thumb');
  const R = 33; // max thumb travel px

  function onStart(e) {
    e.preventDefault();
    const t = e.touches ? e.touches[0] : e;
    const r = base.getBoundingClientRect();
    joystickOrigin = { x: r.left + r.width/2, y: r.top + r.height/2 };
    joystickActive = true;
    logEvent('joystick_start', { round: state.round, playerPos: {...playerPos} });
    startMovementLoop();
  }

  function onMove(e) {
    e.preventDefault();
    if (!joystickActive) return;
    const t = e.touches ? e.touches[0] : e;
    const dx = t.clientX - joystickOrigin.x;
    const dy = t.clientY - joystickOrigin.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const clamped = Math.min(dist, R);
    const angle = Math.atan2(dy, dx);
    joystickDelta = {
      x: Math.cos(angle) * clamped / R,
      y: Math.sin(angle) * clamped / R
    };
    thumb.style.transform = `translate(calc(-50% + ${Math.cos(angle)*clamped}px), calc(-50% + ${Math.sin(angle)*clamped}px))`;
  }

  function onEnd(e) {
    joystickActive = false;
    joystickDelta  = { x: 0, y: 0 };
    thumb.style.transform = 'translate(-50%, -50%)';
    logEvent('joystick_end', { round: state.round, playerPos: {...playerPos} });
  }

  base.addEventListener('touchstart', onStart, { passive: false });
  base.addEventListener('touchmove',  onMove,  { passive: false });
  base.addEventListener('touchend',   onEnd,   { passive: false });
  // Mouse fallback for desktop testing
  base.addEventListener('mousedown', onStart);
  window.addEventListener('mousemove', e => { if (joystickActive) onMove(e); });
  window.addEventListener('mouseup',   onEnd);
}

function startMovementLoop() {
  if (animFrame) return;
  let lastPos = { ...playerPos };
  let stillMs = 0;
  let lastT   = Date.now();

  function tick() {
    animFrame = requestAnimationFrame(tick);
    if (!joystickActive && joystickDelta.x === 0 && joystickDelta.y === 0) {
      stillMs += Date.now() - lastT;
      lastT = Date.now();
      return;
    }
    lastT = Date.now();
    const speed = 1.4;
    playerPos.x = Math.max(SHOOTER_ZONE.xMin, Math.min(SHOOTER_ZONE.xMax, playerPos.x + joystickDelta.x * speed));
    playerPos.y = Math.max(SHOOTER_ZONE.yMin, Math.min(SHOOTER_ZONE.yMax, playerPos.y + joystickDelta.y * speed));

    // track direction changes
    const dx = playerPos.x - lastPos.x;
    const dy = playerPos.y - lastPos.y;
    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
      const lastDx = lastPos.dx || 0;
      if (lastPos.dx !== undefined && Math.sign(dx) !== Math.sign(lastDx) && Math.abs(dx) > 0.3) {
        state.directionChanges++;
      }
      lastPos = { x: playerPos.x, y: playerPos.y, dx, dy };
    }

    // ball sticks to shooter during free movement
    if (!state.primed) {
      ballPos.x = playerPos.x;
      ballPos.y = playerPos.y - 4;
    }

    state.positionHistory.push({ x: playerPos.x, y: playerPos.y, t: Date.now() - state.sessionStart });
    renderPositions();
  }

  tick();
}

// ‚îÄ‚îÄ GOALIE AI ‚îÄ‚îÄ
let goalieAI = null;
function startGoalieAI() {
  if (goalieAI) clearInterval(goalieAI);
  goalieAI = setInterval(() => {
    if (!state.roundActive) return;
    // Goalie tracks shooter x with a lag and some randomness
    const lag  = 0.08 + Math.random() * 0.06;
    const noise = (Math.random() - 0.5) * 8;
    goaliePos.x += (playerPos.x + noise - goaliePos.x) * lag;
    goaliePos.x  = Math.max(GOALIE_PATROL.xMin, Math.min(GOALIE_PATROL.xMax, goaliePos.x));
    renderPositions();
  }, 50);
}

function stopGoalieAI() {
  if (goalieAI) clearInterval(goalieAI);
  goalieAI = null;
}

// ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ
function renderPositions() {
  const pitch = document.getElementById('pitch');
  const pw = pitch.offsetWidth;
  const ph = pitch.offsetHeight;

  const userEl   = document.getElementById('user-player');
  const goalieEl = document.getElementById('goalie-player');
  const ballEl   = document.getElementById('ball');

  setElPos(userEl,   playerPos.x,  playerPos.y,  pw, ph);
  setElPos(goalieEl, goaliePos.x,  goaliePos.y,  pw, ph);
  setElPos(ballEl,   ballPos.x,    ballPos.y,    pw, ph);
}

function setElPos(el, xPct, yPct, pw, ph) {
  el.style.left = (xPct / 100 * pw) + 'px';
  el.style.top  = (yPct / 100 * ph) + 'px';
  el.style.transform = 'translate(-50%, -50%)';
}

// ‚îÄ‚îÄ ROUNDS ‚îÄ‚îÄ
function startRound() {
  state.round++;
  state.roundActive = false;
  state.primed = false;
  state.primeTime = null;
  state.positionHistory = [];

  updateHUD();

  if (state.role === 'shooter') {
    // Reset shooter to bottom center
    playerPos = { x: 50, y: 78 };
    ballPos   = { x: 50, y: 74 };
    goaliePos = { x: 50, y: 12 };
    renderPositions();
    setPrompt('MOVE INTO POSITION');
    startGoalieAI();

    // After a random delay, prime the shot
    const delay = 1800 + Math.random() * 2000;
    setTimeout(primeShot, delay);
  } else {
    setPrompt('WATCH THE BALL...');
    setTimeout(primeGoalie, 1500 + Math.random() * 1500);
  }
}

function primeShot() {
  if (state.round > state.totalRounds) return;
  state.primed = true;
  state.primeTime = Date.now();
  state.roundActive = true;
  setPrompt('SHOOT NOW!');
  document.getElementById('shoot-btn').classList.add('primed');
  setTimeout(() => { if (state.roundActive) resolveRound(false, 'timeout'); }, 1800);
}

function primeGoalie() {
  state.primed = true;
  state.primeTime = Date.now();
  state.roundActive = true;
  setPrompt('DIVE!');
  animateShotAtGoalie();
  setTimeout(() => { if (state.roundActive) resolveRound(false, 'timeout'); }, 1500);
}

function handleShoot() {
  state.tapCount++;
  if (!state.primed) {
    state.earlyTaps++;
    logEvent('early_tap', { round: state.round });
    document.getElementById('shoot-btn').style.borderColor = 'var(--accent-r)';
    setTimeout(() => document.getElementById('shoot-btn').style.borderColor = '', 250);
    return;
  }
  if (!state.roundActive) return;

  const rt = Date.now() - state.primeTime;
  state.reactionTimes.push(rt);
  state.shootPositions.push({ ...playerPos });
  logEvent('shoot', { round: state.round, reactionTime: rt, pos: {...playerPos}, goaliePos: {...goaliePos} });

  // Did the shot beat the goalie? Based on angle/distance gap
  const gap = Math.abs(playerPos.x - goaliePos.x);
  const scored = determineGoal(gap, rt);
  resolveRound(scored, 'shot', rt);
}

function determineGoal(gap, rt) {
  // Wider gap = better chance; faster reaction to shot = harder for goalie
  const baseChance = Math.min(0.85, gap / 40);
  return Math.random() < baseChance;
}

function handleDive(dir) {
  if (!state.roundActive) return;
  const rt = Date.now() - (state.primeTime || Date.now());
  state.reactionTimes.push(rt);
  logEvent('dive', { round: state.round, direction: dir, reactionTime: rt });
  const saved = state.round <= 2 ? Math.random() > 0.35 : Math.random() > 0.55;
  resolveRound(saved, 'dive', rt);
}

function resolveRound(success, method, rt) {
  state.roundActive = false;
  stopGoalieAI();
  document.getElementById('shoot-btn').classList.remove('primed');
  cancelAnimationFrame(animFrame);
  animFrame = null;

  if (success) { state.userScore++; animateGoalFx(true); }
  else         { state.oppScore++;  animateGoalFx(false); }

  logEvent('round_end', { round: state.round, success, method });
  if (state.round >= 2) checkBranch();

  setTimeout(() => {
    if (state.round >= state.totalRounds) finalizeOutcome();
    else startRound();
  }, 1000);
}

// ‚îÄ‚îÄ BRANCHING ‚îÄ‚îÄ
function checkBranch() {
  const avgRT = state.reactionTimes.reduce((a,b) => a+b, 0) / (state.reactionTimes.length || 1);
  const earlyRatio = state.earlyTaps / Math.max(state.tapCount, 1);
  const mover = state.positionHistory.length > 20; // did they actually move?

  if (earlyRatio > 0.3) state.decisionStyle = 'impulsive';
  else if (avgRT < 380 && mover) state.decisionStyle = 'reactive';
  else if (avgRT > 750) state.decisionStyle = 'deliberate';
  else state.decisionStyle = 'calculated';
}

function finalizeOutcome() {
  if (!state.decisionStyle) checkBranch();
  const map = { impulsive: 'lose', reactive: 'lose', deliberate: 'win', calculated: 'win' };
  state.outcome = map[state.decisionStyle] || (Math.random() > 0.5 ? 'win' : 'lose');

  if (state.outcome === 'win') {
    state.userScore = Math.max(state.userScore, 3);
    state.oppScore  = Math.min(state.oppScore, state.userScore - 1);
  } else {
    state.oppScore  = Math.max(state.oppScore, 3);
    state.userScore = Math.min(state.userScore, state.oppScore - 1);
  }
  showResults();
}

// ‚îÄ‚îÄ ANIMATIONS ‚îÄ‚îÄ
function animateGoalFx(scored) {
  const ballEl = document.getElementById('ball');
  const pitch  = document.getElementById('pitch');
  const pw = pitch.offsetWidth, ph = pitch.offsetHeight;

  if (scored) {
    // ball flies to goal
    const tx = (GOAL_X.min + Math.random() * (GOAL_X.max - GOAL_X.min)) / 100 * pw;
    const ty = GOAL_Y / 100 * ph;
    ballEl.style.transition = 'left 0.35s ease-in, top 0.35s ease-in, box-shadow 0.2s';
    ballEl.style.left = tx + 'px';
    ballEl.style.top  = ty + 'px';
    ballEl.style.boxShadow = '0 0 24px rgba(0,229,160,0.9)';
    setPrompt('‚ö° GOAL!');
  } else {
    // ball bounces to goalie
    const gx = goaliePos.x / 100 * pw;
    const gy = goaliePos.y / 100 * ph;
    ballEl.style.transition = 'left 0.25s ease-out, top 0.25s ease-out, box-shadow 0.2s';
    ballEl.style.left = gx + 'px';
    ballEl.style.top  = gy + 'px';
    ballEl.style.boxShadow = '0 0 20px rgba(255,59,59,0.8)';
    setPrompt('SAVED!');
    const gEl = document.getElementById('goalie-player');
    gEl.style.transform = 'translate(-50%,-50%) scale(1.4)';
    setTimeout(() => gEl.style.transform = 'translate(-50%,-50%) scale(1)', 350);
  }

  setTimeout(() => {
    ballEl.style.transition = '';
    ballEl.style.boxShadow  = '0 0 8px rgba(255,255,255,0.6)';
    ballPos = { x: playerPos.x, y: playerPos.y - 4 };
    renderPositions();
  }, 700);
}

function animateShotAtGoalie() {
  const ballEl = document.getElementById('ball');
  const pitch  = document.getElementById('pitch');
  const dir = ['25%','50%','75%'][Math.floor(Math.random()*3)];
  ballEl.style.transition = 'left 0.3s ease-in, top 0.3s ease-in';
  ballEl.style.left = dir;
  ballEl.style.top  = '85%';
  setTimeout(() => ballEl.style.transition = '', 400);
}

// ‚îÄ‚îÄ RESULTS ‚îÄ‚îÄ
function showResults() {
  updateHUD();
  showScreen('screen-result');

  const won = state.outcome === 'win';
  const verdict = document.getElementById('result-verdict');
  verdict.textContent = won
    ? (state.role === 'shooter' ? 'SCORED!' : 'CLEAN SHEET!')
    : (state.role === 'shooter' ? 'DENIED!'  : 'CONCEDED!');
  verdict.className = 'result-verdict ' + (won ? 'win' : 'lose');

  const avgRT = Math.round(state.reactionTimes.reduce((a,b)=>a+b,0) / (state.reactionTimes.length||1));
  document.getElementById('stat-react').textContent    = avgRT + 'ms';
  document.getElementById('stat-attempts').textContent = state.tapCount;
  document.getElementById('stat-score').textContent    = `${state.userScore}‚Äì${state.oppScore}`;

  buildProfileTags();
  generateInsight();
  saveToSupabase();
}

function buildProfileTags() {
  const tags = [];
  const avgRT = state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1);
  tags.push(state.role === 'shooter' ? 'ATTACKER' : 'DEFENDER');
  if (state.earlyTaps > 1)  tags.push('TRIGGER HAPPY');
  if (avgRT < 350)          tags.push('LIGHTNING REFLEX');
  else if (avgRT > 700)     tags.push('PATIENT');
  if (state.directionChanges > 8) tags.push('INDECISIVE');
  if (state.decisionStyle)  tags.push(state.decisionStyle.toUpperCase());
  document.getElementById('profile-tags').innerHTML = tags.map(t => `<span class="tag">${t}</span>`).join('');
}

async function generateInsight() {
  const avgRT = Math.round(state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1));
  const profile = {
    role: state.role, outcome: state.outcome,
    decisionStyle: state.decisionStyle, avgReactionMs: avgRT,
    earlyTaps: state.earlyTaps, totalTaps: state.tapCount,
    directionChanges: state.directionChanges,
    score: `${state.userScore}-${state.oppScore}`
  };

  const prompt = `You are a behavioral psychologist analyzing a floorball game. Write a 2-sentence personality insight based on this player's data. Be specific, a little provocative ‚Äî make it feel like you truly see them. Close with one sharp observation about how they approach real-life challenges.

Data: ${JSON.stringify(profile)}

Only output the insight. No labels, no quotes.`;

  try {
    const res = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-api-key': ANTHROPIC_API_KEY, 'anthropic-version': '2023-06-01' },
      body: JSON.stringify({ model: 'claude-sonnet-4-20250514', max_tokens: 130, messages: [{ role: 'user', content: prompt }] })
    });
    const data = await res.json();
    const text = data.content?.[0]?.text || fallbackInsight(profile);
    const el = document.getElementById('insight-text');
    el.classList.remove('loading');
    el.textContent = text;
  } catch(e) {
    document.getElementById('insight-text').textContent = fallbackInsight(profile);
    document.getElementById('insight-text').classList.remove('loading');
  }
}

function fallbackInsight(p) {
  const lines = {
    impulsive:  "You fire before the picture is clear ‚Äî and sometimes you're right, which makes it worse. In life, you'd rather beg forgiveness than ask permission.",
    reactive:   "You're wired for the moment, not the plan. When pressure arrives you come alive; when it doesn't, you drift. Consistency is your growth edge.",
    deliberate: "You took your time, even when it cost you. That patience is rare and underrated ‚Äî but in a fast game it becomes a liability you have to manage.",
    calculated: "Every move looked considered, even under fire. You play the long game and it shows. The trap: sometimes there's no long game, just now."
  };
  return lines[p.decisionStyle] || lines.calculated;
}

async function saveToSupabase() {
  if (!SUPABASE_URL || SUPABASE_URL.includes('YOUR_')) return;
  const avgRT = Math.round(state.reactionTimes.reduce((a,b)=>a+b,0)/(state.reactionTimes.length||1));
  try {
    await fetch(`${SUPABASE_URL}/rest/v1/floorball_sessions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` },
      body: JSON.stringify({
        role: state.role, outcome: state.outcome,
        decision_style: state.decisionStyle, avg_reaction_ms: avgRT,
        early_taps: state.earlyTaps, total_taps: state.tapCount,
        direction_changes: state.directionChanges,
        final_score: `${state.userScore}-${state.oppScore}`,
        reaction_times: state.reactionTimes,
        shoot_positions: state.shootPositions,
        session_duration_ms: Date.now() - state.sessionStart,
        created_at: new Date().toISOString()
      })
    });
  } catch(e) { /* silent */ }
}

// ‚îÄ‚îÄ UI HELPERS ‚îÄ‚îÄ
function setPrompt(t) { document.getElementById('game-prompt').textContent = t; }
function updateHUD() {
  document.getElementById('score-display').textContent = `${state.userScore} ‚Äì ${state.oppScore}`;
  document.getElementById('round-label').textContent = `RND ${Math.min(state.round, state.totalRounds)}/${state.totalRounds}`;
}
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function shareResult() {
  const text = `I went ${state.userScore}-${state.oppScore} as ${state.role} on FLOORBALL. Profile: ${state.decisionStyle?.toUpperCase()}. Can you beat it?`;
  if (navigator.share) navigator.share({ title: 'FLOORBALL', text, url: window.location.href });
  else { navigator.clipboard?.writeText(text); alert('Copied!'); }
}
function resetGame() {
  stopGoalieAI();
  cancelAnimationFrame(animFrame); animFrame = null;
  state = {
    role: null, round: 0, totalRounds: 5, userScore: 0, oppScore: 0,
    reactionTimes: [], earlyTaps: 0, tapCount: 0,
    primeTime: null, primed: false, roundActive: false,
    outcome: null, sessionStart: Date.now(), decisionStyle: null,
    positionHistory: [], directionChanges: 0, hesitationMs: 0,
    shootPositions: [], _events: []
  };
  playerPos = { x: 50, y: 78 };
  goaliePos = { x: 50, y: 12 };
  ballPos   = { x: 50, y: 74 };
  document.getElementById('insight-text').textContent = 'Analyzing your play style...';
  document.getElementById('insight-text').classList.add('loading');
  showScreen('screen-intro');
}
function logEvent(type, data) {
  state._events.push({ type, data, t: Date.now() - state.sessionStart });
}
-->
</body>
</html>
